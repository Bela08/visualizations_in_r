---
title: "Visualizations in R"
author: "Alex Slavenko and Maria Novosolov"
output:  
  html_document:  
    toc: true  
    toc_float: true
    smooth_scroll: true
    collapsed: false
    # number_sections: true
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

In this workshop we will focus three topics:

1. How to prepare our plots for publication

2. How to create interactive visualizations

3. How to create geographic visualizations

We will use data on per capita alcohol consumption in the countries of the world in 2010. At first, we will explore the data by generating typical plots. We will learn how to manipulate and design these plots to make them publication worthy, and how to turn them into interactive plots. We will then use the same data in ashapefile format to learn how to plot the data on a global map.

First thing is to make sure you have all the libraries uploaded for this session.

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(plotly)
library(leaflet)
library(geojsonio)
library(ggpubr)
library(ggvis)
library(RColorBrewer)
library(extrafont)
library(cowplot)
library(scales)
```

Next, upload the data into your work environment. Make sure to change the path that you are using in the following code to fit the path for the file in your computer.

```{r}
data.vis <- read.csv("C:/visualizations_in_r/country_alcohol.csv")
```
 
Let's view our data:

```{r}
as.tibble(data.vis)
```
Each row in our data is a country. Our columns give data for each country on its population, size (in square km), if it's landlocked or not, if it's an island nation or not, which continent it is on, and the per capita alcohol consumption for 2010: in spirits, beer, wine, and the total consumption.

Now, let's start plotting!

# Publication quality plots

First, we'll plot some data. We'll plot the size of country (log-transformed) on the x axis, and the total alcohol consumption on the y axis. We'll also colour our data based on continent.

```{r}
p <- ggplot(aes(x = SQKM_CNTRY, y = total, colour = Continent), data = data.vis) + geom_point() + ggtitle("Per capita alcohol consumption")
p
```

This basic scatterplot is kind of ugly and uninformative. The good news is this can be improved quite easily, and we can actually make a decent looking plot out of this! We'll do this step by step.

## Colour schemes

Our first step will be colour schemes. The easiest thing to is to use the package 'RColorBrewer'to generate a custom palette from a few nice looking options. With the function 'brewer.pal' you define how many colours you want (6 in our case, for 6 continents), and which  palette you want.

```{r}
my.palette <- brewer.pal(6, "Set3")
p + scale_color_manual(values = my.palette)
```

We can also generate custom color palettes using online tools. There are many different online tools to generate colour palettes, and in this tutorial we will try one nifty one, found on this website: https://palettegenerator.com/ So we'll use this one to make an epic Max Max colour palette!

```{r}
witness.me <- c("#DE8136", "#19191B", "#F6CAB1", "#533927", "#986039", "#166268")
p <- p + scale_color_manual(values = witness.me)
p
```

We'll stick with this palette for the rest of the tutorial.

## Theme layers

Now, let's try and make the plot look a bit better. We can do this using the theme options - theme() has a LOT of different arguments that let you change the way your plot looks. You can change the background, the axes, the gridlines, the fonts, the titles, and the legend.
Modifying elements in the theme is simple, but notice that different elements inherit different functions. For instance, modifying text elements is done using element_text(), whereas modifying line elements is done using element_line(). The one exception is element_blank() - use this for (almost) any type of element that you want to remove from the plot completely.
Here are a few useful examples:

```{r}
p + theme(text = element_text(size = 16)) #change the font size
font_import() #this imports fonts from your computer into R, and may take a lot of time
loadfonts(device = "win") #you may need to change the device, depending on whether you want to print the plot in R or export it
p + theme(text = element_text(family = "Comic Sans MS")) #change the font family (this is horrible, never use comic sans)
p + theme(panel.grid = element_blank()) #remove gridlines
p + theme(panel.background = element_rect(fill = "black")) #change color of background
p + theme(axis.line = element_line(colour = "black")) #add axis lines
p <- p + theme(panel.grid = element_blank(), axis.line = element_line(colour = "black")) #make several changes together
p

```

### Legend manipulation

One of the most useful things you can do is to manipulate the legend. You can rename items in the legend, restyle it, move it around, or just delete it altogether.

```{r}
p + theme(legend.position = "none") #remove the legend
p + theme(legend.position = c(.1,.75)) #move the legend to a different position
p + theme(legend.title = element_blank()) #remove the title of the legend
```

### Axes manipulation

First of all, it's about time we do something about our ugly data. One of our main issues is that the country areas (on the X axis) should be log-transformed. We can transform our data using a simple line of code.

```{r}
p + scale_x_continuous(trans = log10_trans())
```

And to make this look a  bit better, let's change the tick labels to have actual numbers:

```{r}
p <- p + scale_x_continuous(trans = log10_trans(), labels = trans_format("log10", math_format(10^.x)))
p
```


You may also want to change the titles of your axes - this is always useful because usually your data will have column names that are short and easy to type, but less informative for a plot you want to publish.
The expression() function is useful for this, because it allows you to add special characters, as well as create super- and subscripts, italics, etc.

```{r}
p <- p + labs(x = expression("Area (km"^"2"~")"), y = expression("Consumption (l"/"y"~")"))
p
```

## Facets, rotations, etc.

Now we can deal with another problem - this plot is a bit cluttered. It's hard to tell the different continents from one another, which makes it difficult to identify trends. We can solve this via facetting - this is a cool tool that allows us to break up our one plot into several similar plots - they all have the same axes, but they are separated by the factor (continents in this case).

```{r}
p + facet_grid(Continent ~ .) #facet in the vertical direction
p + facet_grid(. ~ Continent) #facet in the horizontal direction
p + facet_wrap( ~ Continent, ncol = 3) #facet in a grid, with a set number of columns (or rows)
```

We've now managed to generate a pretty nice looking plot. You'll see that we all facets have the same range of values in their axes - this allows us to compare the scatterplots in the different levels of our factor (continent), but because they are each in a different "plot", it's a lot less messy and we can see where there is no trend (Europe) and where they might be something going on (Asia).

Now let's try to do something a bit more interesting. Let's try to generate a different plot that allows us to check for differences in alcohol consumption between continents, without taking into acount area. We'll do this using a violin plot, which is a slightly fancier and more informative version of a boxplot. We'll use the same colour palette as we did for the scatterplot.

```{r}
p2 <- ggplot(aes(x = Continent, y = total, fill = Continent), data = data.vis) + 
  geom_violin(trim = F) +
  geom_boxplot(width = .1) +
  geom_jitter(height = 0, width = .1, alpha = .2) +
  scale_fill_manual(values = witness.me) +
  theme(panel.grid = element_blank(), axis.line = element_line(colour = "black")) +
  labs(x = "Continent", y = expression("Consumption (l"/"y"~")")) +
  ggtitle("Per capita alcohol consumption")
p2
```

Now what let's try and combine these two plots - we want to put them both together, side by side.
First thing we'll do is rotate our violin plot. This is very easily done:

```{r}
p2 + coord_flip()
```

Now, we'll use the plot_grid() from the package 'cowplot' to draw the two plots side by side.

```{r}
p <- p + facet_grid(Continent ~ .) + theme(legend.position = "none", strip.background = element_blank(), strip.text = element_blank())
p2 <- p2 + coord_flip() + theme(legend.position = "none", axis.title.y = element_blank(), plot.title = element_text(colour = "white")) + scale_x_discrete(limits = rev(levels(data.vis$Continent)))
p3 <- plot_grid(p, p2)
p3
```


## Export

Finally, it's time to export our plot. There are several formats basic R can export to, the most useful of which are JPG, PNG and PDF. The code for them all follows the same basic format.

```{r}
jpeg("C:/visualizations_in_r/myplot.jpg") #make sure to set your pathway!
p3
dev.off()

png("C:/visualizations_in_r/myplot.png")
p3
dev.off()

pdf("C:/visualizations_in_r/myplot.pdf")
p3
dev.off()
```

### High quality files

As you've probably noticed, while the PDF file looks ok, the JPG and PNG are really poor quality. However, we can fix this. For instance, we can create a TIFF file with a higher resolution and larger size. Also, we can change the size of the PDF, or export to other, different file formats.

```{r}
tiff("C:/visualizations_in_r/myplot.tiff", height = 20, width = 20, units = "cm", res = 300)
p3
dev.off()

pdf("C:/visualizations_in_r/myplot.pdf", height = 20, width = 20)
p3
dev.off()
```

##ggpubr

After we learned all this the hard way, let's learn the easy way. The 'ggpubr' package is the simple way to create nice looking plots. For instance, we can recreate our violin plot using just one line of code, and even add some analysis to it.

```{r}
ggviolin(data.vis, x = "Continent", y = "total", fill = "Continent", palette = witness.me, add = "boxplot", ylab = expression("Consumption (l"/"y"~")")) + geom_jitter(width = .1, alpha = .2) + coord_flip() + theme(legend.position = "none")
```

'ggpubr' has similar types of functions for different types of plots (scatterplots, boxplots, etc.). All look lovely, and require a lot less hassle to generate. It's a package well worth exploring.

# Interactive visualization

In this part we will learn how to create interactive plots and how to use them online and in presentations or Rmd files for reporting our results.

## Introduction to plotly

Plotly is a grate cross platform package that allows a lot of variation for plotting interactive plots. We will use the R version of the package. Lets start with a simple use of the package and that is transforming our ggplots to interactive visualizations with the code ggplotly()

```{r}
# ggplotly()
```

Now we can also just use 
## Introduction to ggvis

## Introduction to 3D


# Geographic plotting

## ggplot2

## leaflet

Read the map shapefile into R. We use geoJSON because it's a lighter file format for geographical data
```{r}
#data.vis.shape <- geojsonio::geojson_read("C:/visualizations_in_r/country_alcohol.geojson", what = "sp")
```

