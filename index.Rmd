---
title: "Visualizations in R"
author: "Alex Slavenko and Maria Novosolov"
output:  
  html_document:  
    toc: true  
    toc_float: true
    smooth_scroll: true
    collapsed: false
  runtime: shiny
    # number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

In this workshop we will focus three topics:

1. How to prepare our plots for publication

2. How to create interactive visualizations

3. How to create geographic visualizations

We will use data on per capita alcohol consumption in the countries of the world in 2010. At first, we will explore the data by generating typical plots. We will learn how to manipulate and design these plots to make them publication worthy, and how to turn them into interactive plots. We will then use the same data in ashapefile format to learn how to plot the data on a global map.

First thing is to make sure you have all the libraries uploaded for this session.

```{r message=FALSE, warning=FALSE, include=FALSE}
if (!require("tidyverse")) install.packages("tidyverse")
if (!require("plotly")) install.packages("plotly")
if (!require("leaflet")) install.packages("leaflet")
if (!require("geojsonio")) install.packages("geojsonio")
if (!require("ggpubr")) install.packages("ggpubr")
if (!require("ggvis")) install.packages("ggvis")
if (!require("RColorBrewer")) install.packages("RColorBrewer")
if (!require("extrafont")) install.packages("extrafont")
if (!require("cowplot")) install.packages("cowplot")
if (!require("scales")) install.packages("scales")
if (!require("ggmap")) install.packages("ggmap")
if (!require("mapdata")) install.packages("mapdata")
if (!require("webshot")) install.packages("webshot")
if (!require("htmlwidgets")) install.packages("htmlwidgets")
if (!require("processx")) install.packages("processx")
if (!require("viridis")) install.packages("viridis")
if (!require("rgeos")) install.packages("rgeos")
```

A bit more preperation before we start: add all the fonts in your computer to R
```{r message=FALSE, warning=FALSE}
# font_import(prompt = F) #this imports fonts from your computer into R, and may take a lot of time
#load the fonts
loadfonts(quiet = T) #you may need to change the device, depending on whether you want to print the plot in R or export it
```

Next, upload the data into your work environment. Make sure to change the path that you are using in the following code to fit the path for the file in your computer.
We will upload the spatial data (the map) that we will use later, and save the metadata as a tibble to use it in the first part of the session.
For your work, make sure to set the working directory with:

setwd("your/path/to/data/file")

or always add it when you read the file in.

```{r}
#upload the spatial file using geojson and specifying to R that it's a shapefile
data_vis.sp<- geojsonio::geojson_read("country_alcohol.geojson",
  what = "sp")
#save the data from the shapefile into a tibble
data_vis<- as_tibble(data_vis.sp@data)
#manipulate the data a bit to make population numeric
data_vis<- data_vis %>% 
  mutate(POP_CNTRY=as.character(POP_CNTRY)) %>% 
  filter(POP_CNTRY!="-99999") %>% 
  mutate(POP_CNTRY=as.numeric(POP_CNTRY))
#remove all the lines with NA's. The function complete.cases removes all the lines that have NA's in them somewhere
data_vis<- data_vis[complete.cases(data_vis),]

```
 
Let's view our data:

```{r}
data_vis
#look at the data. tibble equivalent to str
glimpse(data_vis)
```
Each row in our data is a country. Our columns give data for each country on its population, size (in square km), if it's landlocked or not, if it's an island nation or not, which continent it is on, and the per capita alcohol consumption for 2010: in spirits, beer, wine, and the total consumption.

Now, let's start plotting!

# Publication quality plots

First, we'll plot some data. We'll plot the size of country (log-transformed) on the x axis, and the total alcohol consumption on the y axis. We'll also colour our data based on continent.

```{r message=FALSE, warning=FALSE}
p <- ggplot(aes(x = SQKM_CNTRY, y = total, colour = Continent), data = data_vis) + geom_point() + ggtitle("Per capita alcohol consumption")
p
```

This basic scatterplot is kind of ugly and uninformative. The good news is this can be improved quite easily, and we can actually make a decent looking plot out of this! We'll do this step by step.

## Colour schemes

Our first step will be colour schemes. The easiest thing to is to use the package 'RColorBrewer'to generate a custom palette from a few nice looking options. With the function 'brewer.pal' you define how many colours you want (6 in our case, for 6 continents), and which  palette you want (in this case we use a palette called "Set3" - see the documentation of brewer.pal for all possible palette names).

```{r}
my.palette <- brewer.pal(6, "Set3")
p + scale_color_manual(values = my.palette)
```

We can also generate custom color palettes using online tools. There are many different online tools to generate colour palettes, and in this tutorial we will try one nifty one, found on this website: https://palettegenerator.com/ So we'll use this one to make an epic Max Max colour palette!

```{r message=FALSE, warning=FALSE}
witness.me <- c("#DE8136", "#19191B", "#F6CAB1", "#533927", "#986039", "#166268")
p <- p + scale_color_manual(values = witness.me)
p
```

We'll stick with this palette for the rest of the tutorial.

## Theme layers

Now, let's try and make the plot look a bit better. We can do this using the theme options - theme() has a LOT of different arguments that let you change the way your plot looks. You can change the background, the axes, the gridlines, the fonts, the titles, and the legend.
Modifying elements in the theme is simple, but notice that different elements inherit different functions. For instance, modifying text elements is done using element_text(), whereas modifying line elements is done using element_line(). The one exception is element_blank() - use this for (almost) any type of element that you want to remove from the plot completely.
Here are a few useful examples:

```{r message=FALSE, warning=FALSE}
p + theme(text = element_text(size = 16)) #change the font size
p + theme(text = element_text(family = "Comic Sans MS")) #change the font family (this is horrible, never use comic sans)
p + theme(panel.grid = element_blank()) #remove gridlines
p + theme(panel.background = element_rect(fill = "black")) #change color of background
p + theme(axis.line = element_line(colour = "black")) #add axis lines
p <- p + theme(panel.grid = element_blank(), axis.line = element_line(colour = "black")) #make several changes together
p

```

### Legend manipulation

One of the most useful things you can do is to manipulate the legend. You can rename items in the legend, restyle it, move it around, or just delete it altogether.

```{r message=FALSE, warning=FALSE}
p + theme(legend.position = "none") #remove the legend
p + theme(legend.position = c(.1,.75)) #move the legend to a different position
p + theme(legend.title = element_blank()) #remove the title of the legend
```

### Axes manipulation

First of all, it's about time we do something about our ugly data. One of our main issues is that the country areas (on the X axis) should be log-transformed. We can transform our data using a simple line of code, and some functions from the 'scales' package. Here are some examples, but make sure to check the trans() function documentation and pick the type of transformation that fits your data!

```{r message=FALSE, warning=FALSE}
p + scale_x_continuous(trans = log10_trans()) #log10 transformation
p + scale_x_continuous(trans = sqrt_trans()) #square-root transformation
p + scale_x_continuous(trans = reverse_trans()) #reverse transformation
```

And to make this look a  bit better, let's change the tick labels to have actual numbers. We'll do this with the trans_format() function. We tell the function which transformation to apply to the numbers, and the format in which to write the labels.

```{r}
p <- p + scale_x_continuous(trans = log10_trans(), labels = trans_format("log10", math_format(10^.x)))
p
```


You may also want to change the titles of your axes - this is always useful because usually your data will have column names that are short and easy to type, but less informative for a plot you want to publish.
The expression() function (from base R) is useful for this, because it allows you to add special characters, as well as create super- and subscripts, italics, etc.

```{r}
p <- p + labs(x = expression("Area (km"^"2"~")"), y = expression("Consumption (l"/"y"~")"))
p
```

## Facets, rotations, etc.

Now we can deal with another problem - this plot is a bit cluttered. It's hard to tell the different continents from one another, which makes it difficult to identify trends. We can solve this via facetting - this is a cool tool that allows us to break up our one plot into several similar plots - they all have the same axes, but they are separated by the factor (continents in this case).

```{r}
p + facet_grid(Continent ~ .) #facet in the vertical direction
p + facet_grid(. ~ Continent) #facet in the horizontal direction
p + facet_wrap( ~ Continent, ncol = 3) #facet in a grid, with a set number of columns (or rows)
```

Your plot doesn't have to be faceted by a factor that you've mapped. For instance, we can facet our plot by the factor ISLAND, even though it has no aesthetic mapped to it:

```{r}
p + facet_grid(. ~ ISLAND)
```

We've now managed to generate a pretty nice looking plot. You'll see that we all facets have the same range of values in their axes - this allows us to compare the scatterplots in the different levels of our factor (continent), but because they are each in a different "plot", it's a lot less messy and we can see where there is no trend (Europe) and where they might be something going on (Asia).

Now let's try to do something a bit more interesting. Let's try to generate a different plot that allows us to check for differences in alcohol consumption between continents, without taking into acount area. We'll do this using a violin plot, which is a slightly fancier and more informative version of a boxplot. We'll use the same colour palette as we did for the scatterplot.

```{r}
p2 <- ggplot(aes(x = Continent, y = total, fill = Continent), data = data_vis) + 
  geom_violin(trim = F) +
  geom_boxplot(width = .1) +
  geom_jitter(height = 0, width = .1, alpha = .2) +
  scale_fill_manual(values = witness.me) +
  theme(panel.grid = element_blank(), axis.line = element_line(colour = "black")) +
  labs(x = "Continent", y = expression("Consumption (l"/"y"~")")) +
  ggtitle("Per capita alcohol consumption")
p2
```

Now let's try and combine these two plots - we want to put them both together, side by side.
First thing we'll do is rotate our violin plot. This is very easily done:

```{r}
p2 + coord_flip()
```

Now, we'll use the plot_grid() function from the package 'cowplot' to draw the two plots side by side.

```{r}
p <- p + facet_grid(Continent ~ .) + theme(legend.position = "none", strip.background = element_blank(), strip.text = element_blank())
p2 <- p2 + coord_flip() + theme(legend.position = "none", axis.title.y = element_blank(), plot.title = element_text(colour = "white")) + scale_x_discrete(limits = rev(levels(data_vis$Continent)))
p3 <- plot_grid(p, p2)
p3
```

## Export

Finally, it's time to export our plot. There are several formats basic R can export to, the most useful of which are JPG, PNG and PDF. The code for them all follows the same basic format.

```{r message=FALSE, warning=FALSE}
jpeg("myplot.jpg")
p3
dev.off()

png("myplot.png")
p3
dev.off()

pdf("myplot.pdf")
p3
dev.off()
```

### High quality files

As you've probably noticed, while the PDF file looks ok, the JPG and PNG are really poor quality. However, we can fix this. For instance, we can create a TIFF file with a higher resolution and larger size. Also, we can change the size of the PDF, or export to other, different file formats.

```{r}
tiff("myplot.tiff", height = 20, width = 20, units = "cm", res = 300)
p3
dev.off()

pdf("myplot.pdf", height = 20, width = 20)
p3
dev.off()
```

##ggpubr

After we learned all this the hard way, let's learn the easy way. The 'ggpubr' package is the simple way to create nice looking plots. For instance, we can recreate our violin plot using just one line of code, and even add some analysis to it.

```{r}
ggviolin(data_vis, x = "Continent", y = "total", fill = "Continent", palette = witness.me, add = c("boxplot", "jitter"), ylab = expression("Consumption (l"/"y"~")"), rotate = T, add.params = list(alpha = .2))
```

'ggpubr' has similar types of functions for different types of plots (scatterplots, boxplots, etc.). All look lovely, and require a lot less hassle to generate. It's a package well worth exploring. Here a few examples of the types of plots you can generate with 'ggpubr':

```{r}
#density plots
ggdensity(data_vis, x = "total", color = "Continent", fill = "Continent", palette = witness.me, facet.by = "Continent", xlab = expression("Consumption (l"/"y"~")")) 
#we can also mark the mean (or medians) and add tickmarks (rug = T) to show the actual values of the observations
ggdensity(data_vis, x = "total", add = "mean", rug = T, color = "Continent", fill = "Continent", palette = witness.me, facet.by = "Continent", xlab = expression("Consumption (l"/"y"~")")) 
```

```{r}
#ordered bar plots
ggbarplot(data_vis, x = "CNTRY_NAME", y = "total", color = "Continent", fill = "Continent", palette = witness.me, sort.val = "desc", sort.by.groups = F, x.text.angle = 90, ylab = expression("Consumption (l"/"y"~")"), xlab = "Country") + font("x.text", size = 4)
```

```{r}
#Lollipop chart, as an alternative to barplot
ggdotchart(data_vis, x = "CNTRY_NAME", y = "total", color = "Continent", palette = witness.me, sorting = "descending", rotate = T, group = "Continent", add = "segments", ylab = expression("Consumption (l"/"y"~")"), xlab = "Country") + font("y.text", size = 4)
```

But really, the best way to learn is to just play around with the package and see what it's capable of.

## EXCERCISE
Now it's your turn to try!
We want to know if landlocked countries are home to heavier drinkers - in all three different categories (beer, wine, spirits). So your task is to visualize differences between landlocked and non-landlocked countries in all three of these, in a single plot.
Use whichever visualization method you are most comfortable with, and you think will display the data best for the question we want to ask. Don't forget - visualization is as much design as it is coding! Try to make your figure clear and concise, but also visually appealing. Try to please your own sense of aesthetic first!

# Interactive visualization

In this part we will learn how to create interactive plots and how to use them online, in presentations, or Rmd files for reporting our results.

## Introduction to plotly

Plotly is a grate cross platform package, originating in JavaScript (JS) form, that allows a lot of variation for plotting interactive plots. We will use the R version of the package. 
It can be used in two ways, the simplest use of the package, is to use `ggplotly()` which transformes `ggplot` object to an interactive visualizations. This is done with the code 

```{r}
#create a ggplot object
p <- ggplot(aes(x = SQKM_CNTRY, y = total, colour = Continent), data = data_vis) + geom_point() + ggtitle("Per capita alcohol consumption") + scale_colour_manual(values = witness.me) + scale_x_continuous(trans = log10_trans())
p
#transform in to an interactive object
ggplotly(p)
```

The other option is to transfer data into and interactive object, this is done with the `plot_ly()` function. This function was originally created to allow create plots that were not available with `ggplot` such as 3D and mash plots. However, today you can create any plot with this function, and majority of `ggplot` objects can be transformed into a `plotly` object. 

We will anyway learn a bit about the `plot_ly()` syntex for you to be able to use the power of the JS library in R

### `plot_ly()` syntex
This function is extremely versitile and it allows you to control and change every small thing on the plot.
The `plot_ly()` function uses the pipe symbol `%>%` to add traces which are equivalent to `geom` in `ggplot` and describes the type of plot you want, and layers which are anything you want to change or add to the the type of plot. Scatter is the default type. Lets look at the most basic `plot_ly()` plot: Number of beer liters consumed as a function of country size

```{r message=FALSE, warning=FALSE}

plot_ly(data_vis,x=~log10(SQKM_CNTRY),y=~beer, type = 'scatter')
```

#### Adding color
Now lets add a descrete variable to use as color variable in the plot. We use whether it's and island or not
```{r message=FALSE, warning=FALSE}
plot_ly(data_vis,x=~log10(SQKM_CNTRY),y=~beer, type = 'scatter',color =~ ISLAND)

```

We can change the colors to what we want
```{r message=FALSE, warning=FALSE}
plot_ly(data_vis,x=~log10(SQKM_CNTRY),y=~beer, type = 'scatter',color =~ISLAND,colors = "Set1")
```

#### Legend position
We can change the ledgend position

```{r message=FALSE, warning=FALSE}
#legende bottom
plot_ly(data_vis,
        x=~log10(SQKM_CNTRY),
        y=~beer, 
        type = 'scatter',
        color =~ISLAND,
        colors = "Set1") %>% 
   layout(legend = list(orientation = 'h'))
  
#legend witin plot
plot_ly(data_vis,
        x=~log10(SQKM_CNTRY),
        y=~beer, 
        type = 'scatter',
        color =~ISLAND,
        colors = "Set1") %>% 
layout(legend = list(x = 0.1, y = 0.9))

#no ledgend
plot_ly(data_vis,
        x=~log10(SQKM_CNTRY),
        y=~beer, 
        type = 'scatter',
        color =~ISLAND,
        colors = "Set1") %>% 
  layout(showlegend = FALSE)
  
```

#### Change axis names
```{r message=FALSE, warning=FALSE}
plot_ly(data_vis,
        x=~log10(SQKM_CNTRY),
        y=~beer, 
        type = 'scatter',
        color =~ISLAND,
        colors = "Set1") %>% 
layout(legend = list(x = 0.1, y = 0.9),
       xaxis = list(title = "where in the world",
                    titlefont = list(family = "Comic Sans MS",size = 18)),
       yaxis = list(title = "Beer consumption",
                    titlefont = list(family = "Courier New, monospace", size =30)))
```

A cleaner way to do the same

```{r message=FALSE, warning=FALSE}
#first font
f1 = list(family = "Comic Sans MS",size = 18)
#second font
f2 = list(family = "Courier New, monospace", size =30)
#xaxis
x = list(title = "where in the world", titlefont = f1)
#yaxis
y = list(title = "Beer consumption", titlefont = f2)

#make the plot
plot_ly(data_vis,
        x=~log10(SQKM_CNTRY),
        y=~beer, 
        type = 'scatter',
        color =~ISLAND,
        colors = "Set1") %>% 
layout(legend = list(x = 0.1, y = 0.9),
       xaxis = x,
       yaxis = y)
```

#### Plot side by side
We can plot side by side for each factor in the descrete variable. Make sure that the data you want to plot is in a long format.

```{r message=FALSE, warning=FALSE}
p <- data_vis %>%
  #transform the variable that will be used to plot to integer type
  transform(id = as.integer(factor(ISLAND))) %>%
  #plot the data where X is the predictor, y is the response, color is thedivider, yaxis is the variable to use to divide the plot
  plot_ly(x = ~beer, y = ~total, color = ~ISLAND, colors = "Dark2",type = "scatter",
          yaxis = ~paste0("y", id)) %>%
  # define the number of subplots and share the x to plot them together
  subplot(nrows = 2, shareX = TRUE)
p
```

#### Line plot in subblot
e can put lines instead of dots by removing the "scatter" as type and adding the line `add_lines()`

```{r message=FALSE, warning=FALSE}
p <- data_vis %>%
  #transform the variable that will be used to plot to integer type
  transform(id = as.integer(factor(ISLAND))) %>%
  #plot the data where X is the predictor, y is the response, color is thedivider, yaxis is the variable to use to divide the plot
  plot_ly(x = ~beer, y = ~total, color = ~ISLAND, colors = "Dark2",
          yaxis = ~paste0("y", id)) %>%
  #make a line graph instead of just scatterplot
  add_lines() %>%
  # define the number of subplots and share the x to plot them together
  subplot(nrows = 2, shareX = TRUE)
p

```

#### Change the size of the dots based on a variable
```{r message=FALSE, warning=FALSE}
#change size for all dots
p<- plot_ly(data_vis,
        x=~log10(SQKM_CNTRY),
        y=~wine, 
        type = 'scatter',
        color =~LANDLOCKED,
        colors = "Set1",
        mode = "markers",
        marker = list(size = 20)) %>% 
  layout(showlegend = FALSE)
p

#change size based on a continious factor
p<- plot_ly(data_vis,
        x=~log10(SQKM_CNTRY),
        y=~log10(POP_CNTRY), 
        type = 'scatter',
        mode = "markers",
        size = ~total,
        color =~LANDLOCKED,
        colors = "Set1") %>% 
  layout(showlegend = FALSE)
p
```

#### Do line plots
```{r}
plot_ly(data_vis, x = ~log10(POP_CNTRY), y = ~log10(SQKM_CNTRY)) %>%
  add_lines(color = ~LANDLOCKED, colors = "Set1", alpha = 0.9)
```

#### Barplot 
```{r}
p2 <- data_vis %>%
  dplyr::count(Continent) %>%
  plot_ly(x = ~Continent, y = ~n) %>% 
  add_bars()

```

#### Proportion barplot

```{r message=FALSE, warning=FALSE}
# number of wines by continent and whether its and island (n)
cc <- count(data_vis, Continent, ISLAND)
# number of diamonds by Continent (nn)
cc2 <- left_join(cc, count(cc, Continent, wt = n))
cc2 %>%
  mutate(prop = n / nn) %>%
  plot_ly(x = ~Continent, y = ~prop, color = ~ISLAND) %>%
  add_bars() %>%
  layout(barmode = "stack")
```

#### Boxplot 
```{r message=FALSE, warning=FALSE}
#Standard boxplot
p <- plot_ly(data_vis, y = ~total, color = I("darkgreen"), 
             boxpoints = "suspectedoutliers")%>% 
  add_boxplot(x = ~Continent)
p
#faceted boxplot
p<- plot_ly(data_vis, x = ~wine, y = ~interaction(ISLAND, Continent)) %>%
  add_boxplot(color = ~ISLAND) %>%
  layout(yaxis = list(title = ""), margin = list(l = 100))
p
```

#### Exporting localy as html widget 
This can be used in a website or presentation
```{r message=FALSE, warning=FALSE}
htmlwidgets::saveWidget(p, "my_pot.html")
```

#### Export static

To export a high quality static plot from `plot_ly()` you need to install an additional package for your OS names orca. Follow this github to unstall it:
https://github.com/plotly/orca#installation
Then write 
```{r}
# orca(p, file='image.png',width = 10,height = 10)
```

#### To summarize
__Pros__: A strong tool for interactive ploting especially if you want to use Shiny.
__Cons__: Syntex is not intuetive and needs some time to get used to if you don't know JS

## Introduction to ggvis
`ggvis` is a good alternative to `plotly` and to `ggplot` because the structure of the object is similar to `ggplot2` but with ` %>% ` instead of `+`. To use the package we will use `ggvis()`. 
I will show here a few examples of how to use ggvis and in the end you can find a list of links that can be useful to deepen your understanding in the package.

### Basic `ggvis()` plots
The basic plots are static just as ggplot, but perhaps need less writing to produce.

#### Scatterplot
We'll start with a scatterplot
```{r}
p<- data_vis %>% 
  ggvis(x =~log10(POP_CNTRY),y =~spirits) %>% 
  layer_points()
p
```

#### Adding variables to plot
You can add more variables to the plot by mapping them to other visual properties:
`fill` = color
`stroke`=color pelet
`size` = size of the symbols
`shape`= shale of the symbols
```{r}
data_vis %>% 
  ggvis(x =~log10(POP_CNTRY),
        y =~spirits,fill=~Continent,size =~wine,shape =~ISLAND) %>% 
  layer_points()

```

To use a fix color or size instead of a variable, use `:=`
```{r}
data_vis %>% 
  ggvis(x =~log10(POP_CNTRY),y =~spirits,fill:="red",size :=30,shape :="square") %>% 
  layer_points()
```

#### Add grouping with `group_by()`
```{r}
data_vis %>% 
ggvis(x = ~wine, y = ~beer) %>% 
  layer_points(fill = ~Continent) %>%
  group_by(Continent) %>% 
  layer_model_predictions(model = "lm",se = T)
```

#### Fix legend
```{r}
data_vis %>% 
ggvis(x = ~wine, y = ~beer) %>% 
  layer_points(fill = ~Continent,size =~total) %>%
  group_by(Continent) %>% 
 add_legend(c("size", "fill"),
            orient = "left")
```

#### Histogram
```{r}
data_vis %>% 
  ggvis(~spirits,fill:="darkgreen") %>% 
  layer_histograms()
```


#### Barplot
```{r}
data_vis %>% 
  ggvis(~log10(POP_CNTRY), ~wine) %>%
  layer_bars(width = 0.04)
```

#### Line plot
```{r}
data_vis %>% 
  ggvis(~log10(POP_CNTRY), ~log10(SQKM_CNTRY)) %>%
  layer_lines()
```

#### Boxplot
```{r}
data_vis %>% 
  ggvis(x=~Continent, y=~wine,fill:="darkblue") %>% 
  layer_boxplots()
```

#### Make the plot interactive
`ggvis` gives an option of interactive plotting. It is different than the interactive plotting in `plotly` but maybe useful for other things. 

##### Change symbol size
For example we can allows the user to change the size of the points and the transperacy using a slider
```{r}
#add sliders to the size and the opacity
data_vis %>% 
  ggvis(x =~log10(POP_CNTRY),
        y =~spirits,
        fill:="red",
        size := input_slider(10, 300),
        opacity := input_slider(0, 1)
        ) %>% 
  layer_points()
```

##### Input a check box
```{r message=FALSE, warning=FALSE}

model_type <- input_checkbox(label = "Use flexible curve",
  map = function(val) if(val) "loess" else "lm")
ggvis(data = data_vis,x=~total, y=~spirits) %>%
  layer_model_predictions(model = model_type)
```

##### To summarize
`ggvis` is a good tool to create plots in R and is in some ways similar to `ggplot2`
__Pros__: Uses less lines than `ggplot` to create the same plot
__Cons__: Has less documentation and forums which makes it a bit harder to learn 

Here is a good comperison review of `ggplot2` vs. `ggvis` and the difference between them 
https://stats.stackexchange.com/questions/117078/for-plotting-with-r-should-i-learn-ggplot2-or-ggvis/117080

Here is  a good comparison between the different available packages for plotting in R
http://ouzor.github.io/blog/2014/11/21/interactive-visualizations.html

## Introduction to 3D


# Geographic plotting

We can plot two types of geographical plots in R - static (`ggplot2`) and interactive (`leaflet`). There are some more packages out there you can find some links in the end of this section.

## ggplot2

### Manipulating the data
To plot geographical data with `ggplot` you first need to change the structure of the data. We will use the shapefile `data_vis.sp` that we created befor.

To use the shapefile in `ggplot2` we have to first `fortify` the spatial attribute of our data and then join the metadata back to the new spatial data

```{r}
#add an ID field to the metadata
data_vis.sp@data$ID<- c(1:length(data_vis.sp@data$FIPS_CNTRY))
#add the centroid to use later
trueCentroids = gCentroid(data_vis.sp,byid=TRUE)
#save the coordinates to tibble
trueCentroids_d<- as_tibble(trueCentroids@coords)
#add ID
trueCentroids@coords$ID<- c(1:(length(trueCentroids@coords)/2))
# join them to the data
data_vis.sp@data<- left_join(data_vis.sp@data,trueCentroids_d,x="ID",y="ID")
#save the metadata in a new object
data_vis.sp_d<- data_vis.sp@data
#fortify the data
data_vis.sp_f <- fortify(data_vis.sp, region = "ID") %>% 
  mutate(id = as.numeric(id))
# now we join the thematic data
map_data <- data_vis.sp_f %>% left_join(data_vis.sp_d, by = c("id" = "ID"))
```

### Basic map

```{r}
p <- ggplot() +
    # municipality polygons
    geom_polygon(data = map_data, aes(fill = beer, 
                                      x = long, 
                                      y = lat, 
                                      group = group)) +
    # municipality outline
    geom_path(data = map_data, aes(x = long, 
                                   y = lat, 
                                   group = group), 
              color = "white", size = 0.1) +
    coord_equal() +
    # add the previously defined basic theme
    theme_map() +
    labs(x = NULL, 
         y = NULL, 
         title = "Beer consumption around the world", 
         subtitle = "Litters consumed per capita"
         )
p
#change the color to have a nicer color scheme
p+scale_fill_viridis(option = "magma", direction = -1)
```

### Change the ledgend position

```{r}
q <- p +
  # this is the main part
  theme(legend.position = "bottom") +
  scale_fill_viridis(
    option = "magma", 
    direction = -1,
    name = "Litters per country",
    # here we use guide_colourbar because it is still a continuous scale
    guide = guide_colorbar(
      direction = "horizontal",
      barheight = unit(2, units = "mm"),
      barwidth = unit(50, units = "mm"),
      draw.ulim = F,
      title.position = 'top',
      # some shifting around
      title.hjust = 0.5,
      label.hjust = 0.5
  ))
q
```

### Plot a descrete variable

```{r}
p <- ggplot() +
    # municipality polygons
    geom_polygon(data = map_data, aes(fill = Continent, 
                                      x = long, 
                                      y = lat, 
                                      group = group)) +
    # municipality outline
    geom_path(data = map_data, aes(x = long, 
                                   y = lat, 
                                   group = group), 
              color = "white", size = 0.1) +
    coord_equal() +
    theme_map() +
    theme(legend.position = "bottom") +
    labs(x = NULL, 
         y = NULL, 
         title = "The continents of the world")
brks_scale <- levels(map_data$Continent)
labels_scale <- rev(brks_scale)
q <- p +
    # now we have to use a manual scale, 
    # because only ever one number should be shown per label
    scale_fill_manual(
          # in manual scales, one has to define colors, well, manually
          # I can directly access them using viridis' magma-function
          values = rev(magma(6)),
          breaks = rev(brks_scale),
          name = "Continents",
          drop = FALSE,
          labels = labels_scale,
          guide = guide_legend(
            direction = "horizontal",
            title.position = 'top',
            # I shift the labels around, the should be placed 
            # exactly at the right end of each legend key
            title.hjust = 0.5,
            label.hjust = 1,
            nrow = 1,
            byrow = T,
            # also the guide needs to be reversed
            reverse = T,
            label.position = "bottom"
          )
      )

q
```

A link to more things you can add to the plot 
https://timogrossenbacher.ch/2016/12/beautiful-thematic-maps-with-ggplot2-only/

### Add bubble plots
```{r}
geom_point(data = cap_bubble, aes(cap_long, cap_lat, size = no_car_k), 
             shape = 21, fill = "red", alpha = .5)                       +
  scale_size_area(max_size=20)
```

### EXCERSISE

Plot each one of the alcohol consumption types data on a map and put them next to eachother in a grid plot of 2X2




For this we need a few packages that we uploaded before: `maps`, `mapdata`, and `ggplot2`
* The `maps` package contains a lot of outlines of continents, countries, states, and counties that have been with R for a long time.
* The `mapdata` package contains a few more, higher-resolution outlines.
* The `maps` package comes with a plotting function, but, we will opt to use `ggplot2` to plot the maps in the `maps` package.
* Recall that `ggplot2` operates on data frames. Therefore we need some way to translate the maps data into a data frame format the `ggplot` can use.

First we'll create a world map tamplate that we will use to map our data on it
```{r}
w2hr <- map_data("world2Hires")
```

## leaflet



