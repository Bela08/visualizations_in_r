---
title: "Visualizations in R"
author: "Alex Slavenko and Maria Novosolov"
output:  
  html_document:  
    toc: true  
    toc_float: true
    smooth_scroll: true
    collapsed: false
    # number_sections: true
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

In this workshop we will focus three topics:

1. How to prepare our plots for publication

2. How to create interactive visualizations

3. How to create geographic visualizations

We will use data on per capita alcohol consumption in the countries of the world in 2010. At first, we will explore the data by generating typical plots. We will learn how to manipulate and design these plots to make them publication worthy, and how to turn them into interactive plots. We will then use the same data in ashapefile format to learn how to plot the data on a global map.

First thing is to make sure you have all the libraries uploaded for this session.

```{r message=FALSE, warning=FALSE}
if (!require("tidyverse")) install.packages("tidyverse")
if (!require("plotly")) install.packages("plotly")
library(plotly)
library(leaflet)
library(geojsonio)
library(ggpubr)
library(ggvis)
library(RColorBrewer)
library(extrafont)
library(cowplot)
library(scales)
library(ggmap)
library(mapdata)
if (!require("webshot")) install.packages("webshot")
if (!require("htmlwidgets")) install.packages("htmlwidgets")
if (!require("processx")) install.packages("processx")
```

A bit more preperation before we start: add all the fonts in your computer to R
```{r message=FALSE, warning=FALSE}
# font_import(prompt = F) #this imports fonts from your computer into R, and may take a lot of time
#load the fonts
loadfonts(quiet = T) #you may need to change the device, depending on whether you want to print the plot in R or export it
```

Next, upload the data into your work environment. Make sure to change the path that you are using in the following code to fit the path for the file in your computer.
We will upload the spatial data (the map) that we will use later, and save the metadata as a tibble to use it in the first part of the session.
For your work, make sure to set the working directory with:

setwd("your/path/to/data/file")

or always add it when you read the file in.

```{r}
#upload the spatial file using geojson and specifying to R that it's a shapefile
data.vis.sp<- geojsonio::geojson_read("country_alcohol.geojson",
  what = "sp")
#save the data from the shapefile into a tibble
data.vis<- as_tibble(data.vis.sp@data)
#manipulate the data a bit to make population numeric
data.vis<- data.vis %>% 
  mutate(POP_CNTRY=as.character(POP_CNTRY)) %>% 
  filter(POP_CNTRY!="-99999") %>% 
  mutate(POP_CNTRY=as.numeric(POP_CNTRY))
#remove all the lines with NA's. The function complete.cases removes all the lines that have NA's in them somewhere
data.vis<- data.vis[complete.cases(data.vis),]
#look at the data. tibble equivalent to str
glimpse(data.vis)
```
 
Let's view our data:

```{r}
data.vis
```
Each row in our data is a country. Our columns give data for each country on its population, size (in square km), if it's landlocked or not, if it's an island nation or not, which continent it is on, and the per capita alcohol consumption for 2010: in spirits, beer, wine, and the total consumption.

Now, let's start plotting!

# Publication quality plots

First, we'll plot some data. We'll plot the size of country (log-transformed) on the x axis, and the total alcohol consumption on the y axis. We'll also colour our data based on continent.

```{r message=FALSE, warning=FALSE}
p <- ggplot(aes(x = SQKM_CNTRY, y = total, colour = Continent), data = data.vis) + geom_point() + ggtitle("Per capita alcohol consumption")
p
```

This basic scatterplot is kind of ugly and uninformative. The good news is this can be improved quite easily, and we can actually make a decent looking plot out of this! We'll do this step by step.

## Colour schemes

Our first step will be colour schemes. The easiest thing to is to use the package 'RColorBrewer'to generate a custom palette from a few nice looking options. With the function 'brewer.pal' you define how many colours you want (6 in our case, for 6 continents), and which  palette you want (in this case we use a palette called "Set3" - see the documentation of brewer.pal for all possible palette names).

```{r}
my.palette <- brewer.pal(6, "Set3")
p + scale_color_manual(values = my.palette)
```

We can also generate custom color palettes using online tools. There are many different online tools to generate colour palettes, and in this tutorial we will try one nifty one, found on this website: https://palettegenerator.com/ So we'll use this one to make an epic Max Max colour palette!

```{r message=FALSE, warning=FALSE}
witness.me <- c("#DE8136", "#19191B", "#F6CAB1", "#533927", "#986039", "#166268")
p <- p + scale_color_manual(values = witness.me)
p
```

We'll stick with this palette for the rest of the tutorial.

## Theme layers

Now, let's try and make the plot look a bit better. We can do this using the theme options - theme() has a LOT of different arguments that let you change the way your plot looks. You can change the background, the axes, the gridlines, the fonts, the titles, and the legend.
Modifying elements in the theme is simple, but notice that different elements inherit different functions. For instance, modifying text elements is done using element_text(), whereas modifying line elements is done using element_line(). The one exception is element_blank() - use this for (almost) any type of element that you want to remove from the plot completely.
Here are a few useful examples:

```{r message=FALSE, warning=FALSE}
p + theme(text = element_text(size = 16)) #change the font size
p + theme(text = element_text(family = "Comic Sans MS")) #change the font family (this is horrible, never use comic sans)
p + theme(panel.grid = element_blank()) #remove gridlines
p + theme(panel.background = element_rect(fill = "black")) #change color of background
p + theme(axis.line = element_line(colour = "black")) #add axis lines
p <- p + theme(panel.grid = element_blank(), axis.line = element_line(colour = "black")) #make several changes together
p

```

### Legend manipulation

One of the most useful things you can do is to manipulate the legend. You can rename items in the legend, restyle it, move it around, or just delete it altogether.

```{r message=FALSE, warning=FALSE}
p + theme(legend.position = "none") #remove the legend
p + theme(legend.position = c(.1,.75)) #move the legend to a different position
p + theme(legend.title = element_blank()) #remove the title of the legend
```

### Axes manipulation

First of all, it's about time we do something about our ugly data. One of our main issues is that the country areas (on the X axis) should be log-transformed. We can transform our data using a simple line of code, and some functions from the 'scales' package. Here are some examples, but make sure to check the trans() function documentation and pick the type of transformation that fits your data!

```{r message=FALSE, warning=FALSE}
p + scale_x_continuous(trans = log10_trans()) #log10 transformation
p + scale_x_continuous(trans = sqrt_trans()) #square-root transformation
p + scale_x_continuous(trans = reverse_trans()) #reverse transformation
```

And to make this look a  bit better, let's change the tick labels to have actual numbers. We'll do this with the trans_format() function. We tell the function which transformation to apply to the numbers, and the format in which to write the labels.

```{r}
p <- p + scale_x_continuous(trans = log10_trans(), labels = trans_format("log10", math_format(10^.x)))
p
```


You may also want to change the titles of your axes - this is always useful because usually your data will have column names that are short and easy to type, but less informative for a plot you want to publish.
The expression() function (from base R) is useful for this, because it allows you to add special characters, as well as create super- and subscripts, italics, etc.

```{r}
p <- p + labs(x = expression("Area (km"^"2"~")"), y = expression("Consumption (l"/"y"~")"))
p
```

## Facets, rotations, etc.

Now we can deal with another problem - this plot is a bit cluttered. It's hard to tell the different continents from one another, which makes it difficult to identify trends. We can solve this via facetting - this is a cool tool that allows us to break up our one plot into several similar plots - they all have the same axes, but they are separated by the factor (continents in this case).

```{r}
p + facet_grid(Continent ~ .) #facet in the vertical direction
p + facet_grid(. ~ Continent) #facet in the horizontal direction
p + facet_wrap( ~ Continent, ncol = 3) #facet in a grid, with a set number of columns (or rows)
```

Your plot doesn't have to be faceted by a factor that you've mapped. For instance, we can facet our plot by the factor ISLAND, even though it has no aesthetic mapped to it:

```{r}
p + facet_grid(. ~ ISLAND)
```

We've now managed to generate a pretty nice looking plot. You'll see that we all facets have the same range of values in their axes - this allows us to compare the scatterplots in the different levels of our factor (continent), but because they are each in a different "plot", it's a lot less messy and we can see where there is no trend (Europe) and where they might be something going on (Asia).

Now let's try to do something a bit more interesting. Let's try to generate a different plot that allows us to check for differences in alcohol consumption between continents, without taking into acount area. We'll do this using a violin plot, which is a slightly fancier and more informative version of a boxplot. We'll use the same colour palette as we did for the scatterplot.

```{r}
p2 <- ggplot(aes(x = Continent, y = total, fill = Continent), data = data.vis) + 
  geom_violin(trim = F) +
  geom_boxplot(width = .1) +
  geom_jitter(height = 0, width = .1, alpha = .2) +
  scale_fill_manual(values = witness.me) +
  theme(panel.grid = element_blank(), axis.line = element_line(colour = "black")) +
  labs(x = "Continent", y = expression("Consumption (l"/"y"~")")) +
  ggtitle("Per capita alcohol consumption")
p2
```

Now let's try and combine these two plots - we want to put them both together, side by side.
First thing we'll do is rotate our violin plot. This is very easily done:

```{r}
p2 + coord_flip()
```

Now, we'll use the plot_grid() function from the package 'cowplot' to draw the two plots side by side.

```{r}
p <- p + facet_grid(Continent ~ .) + theme(legend.position = "none", strip.background = element_blank(), strip.text = element_blank())
p2 <- p2 + coord_flip() + theme(legend.position = "none", axis.title.y = element_blank(), plot.title = element_text(colour = "white")) + scale_x_discrete(limits = rev(levels(data.vis$Continent)))
p3 <- plot_grid(p, p2)
p3
```

## Export

Finally, it's time to export our plot. There are several formats basic R can export to, the most useful of which are JPG, PNG and PDF. The code for them all follows the same basic format.

```{r}
jpeg("myplot.jpg")
p3
dev.off()

png("myplot.png")
p3
dev.off()

pdf("myplot.pdf")
p3
dev.off()
```

### High quality files

As you've probably noticed, while the PDF file looks ok, the JPG and PNG are really poor quality. However, we can fix this. For instance, we can create a TIFF file with a higher resolution and larger size. Also, we can change the size of the PDF, or export to other, different file formats.

```{r}
tiff("myplot.tiff", height = 20, width = 20, units = "cm", res = 300)
p3
dev.off()

pdf("myplot.pdf", height = 20, width = 20)
p3
dev.off()
```

##ggpubr

After we learned all this the hard way, let's learn the easy way. The 'ggpubr' package is the simple way to create nice looking plots. For instance, we can recreate our violin plot using just one line of code, and even add some analysis to it.

```{r}
ggviolin(data.vis, x = "Continent", y = "total", fill = "Continent", palette = witness.me, add = c("boxplot", "jitter"), ylab = expression("Consumption (l"/"y"~")"), rotate = T, add.params = list(alpha = .2))
```

'ggpubr' has similar types of functions for different types of plots (scatterplots, boxplots, etc.). All look lovely, and require a lot less hassle to generate. It's a package well worth exploring. Here a few examples of the types of plots you can generate with 'ggpubr':

```{r}
#density plots
ggdensity(data.vis, x = "total", color = "Continent", fill = "Continent", palette = witness.me, facet.by = "Continent", xlab = expression("Consumption (l"/"y"~")")) 
#we can also mark the mean (or medians) and add tickmarks (rug = T) to show the actual values of the observations
ggdensity(data.vis, x = "total", add = "mean", rug = T, color = "Continent", fill = "Continent", palette = witness.me, facet.by = "Continent", xlab = expression("Consumption (l"/"y"~")")) 
```

```{r}
#ordered bar plots
ggbarplot(data.vis, x = "CNTRY_NAME", y = "total", color = "Continent", fill = "Continent", palette = witness.me, sort.val = "desc", sort.by.groups = F, x.text.angle = 90, ylab = expression("Consumption (l"/"y"~")"), xlab = "Country") + font("x.text", size = 4)
```

```{r}
#Lollipop chart, as an alternative to barplot
ggdotchart(data.vis, x = "CNTRY_NAME", y = "total", color = "Continent", palette = witness.me, sorting = "descending", rotate = T, group = "Continent", add = "segments", ylab = expression("Consumption (l"/"y"~")"), xlab = "Country") + font("y.text", size = 4)
```

But really, the best way to learn is to just play around with the package and see what it's capable of.

## EXCERCISE
Now it's your turn to try!
We want to know if landlocked countries are home to heavier drinkers - in all three different categories (beer, wine, spirits). So your task is to visualize differences between landlocked and non-landlocked countries in all three of these, in a single plot.
Use whichever visualization method you are most comfortable with, and you think will display the data best for the question we want to ask. Don't forget - visualization is as much design as it is coding! Try to make your figure clear and concise, but also visually appealing. Try to please your own sense of aesthetic first!

# Interactive visualization

In this part we will learn how to create interactive plots and how to use them online, in presentations, or Rmd files for reporting our results.

## Introduction to plotly

Plotly is a grate cross platform package, originating in JavaScript (JS) form, that allows a lot of variation for plotting interactive plots. We will use the R version of the package. 
It can be used in two ways, the simplest use of the package, is to use `ggplotly()` which transformes `ggplot` object to an interactive visualizations. This is done with the code 

```{r}
#create a ggplot object
p <- ggplot(aes(x = SQKM_CNTRY, y = total, colour = Continent), data = data.vis) + geom_point() + ggtitle("Per capita alcohol consumption") + scale_colour_manual(values = witness.me) + scale_x_continuous(trans = log10_trans())
p
#transform in to an interactive object
ggplotly(p)
```

The other option is to transfer data into and interactive object, this is done with the `plot_ly()` function. This function was originally created to allow create plots that were not available with `ggplot` such as 3D and mash plots. However, today you can create any plot with this function, and majority of `ggplot` objects can be transformed into a `plotly` object. 

We will anyway learn a bit about the `plot_ly()` syntex for you to be able to use the power of the JS library in R

### `plot_ly()` syntex
This function is extremely versitile and it allows you to control and change every small thing on the plot.
The `plot_ly()` function uses the pipe symbol `%>%` to add traces which are equivalent to `geom` in `ggplot` and describes the type of plot you want, and layers which are anything you want to change or add to the the type of plot. Scatter is the default type. Lets look at the most basic `plot_ly()` plot: Number of beer liters consumed as a function of country size

```{r message=FALSE, warning=FALSE}

plot_ly(data.vis,x=~log10(SQKM_CNTRY),y=~beer, type = 'scatter')
```

Now lets add a descrete variable to use as color variable in the plot. We use whether it's and island or not
```{r message=FALSE, warning=FALSE}
plot_ly(data.vis,x=~log10(SQKM_CNTRY),y=~beer, type = 'scatter',color =~ ISLAND)

```

We can change the colors to what we want
```{r message=FALSE, warning=FALSE}
plot_ly(data.vis,x=~log10(SQKM_CNTRY),y=~beer, type = 'scatter',color =~ISLAND,colors = "Set1")
```

We can change the ledgend position

```{r message=FALSE, warning=FALSE}
#legende bottom
plot_ly(data.vis,
        x=~log10(SQKM_CNTRY),
        y=~beer, 
        type = 'scatter',
        color =~ISLAND,
        colors = "Set1") %>% 
   layout(legend = list(orientation = 'h'))
  
#legend witin plot
plot_ly(data.vis,
        x=~log10(SQKM_CNTRY),
        y=~beer, 
        type = 'scatter',
        color =~ISLAND,
        colors = "Set1") %>% 
layout(legend = list(x = 0.1, y = 0.9))

#no ledgend
plot_ly(data.vis,
        x=~log10(SQKM_CNTRY),
        y=~beer, 
        type = 'scatter',
        color =~ISLAND,
        colors = "Set1") %>% 
  layout(showlegend = FALSE)
  
```

Change axis names
```{r message=FALSE, warning=FALSE}
plot_ly(data.vis,
        x=~log10(SQKM_CNTRY),
        y=~beer, 
        type = 'scatter',
        color =~ISLAND,
        colors = "Set1") %>% 
layout(legend = list(x = 0.1, y = 0.9),
       xaxis = list(title = "where in the world",
                    titlefont = list(family = "Comic Sans MS",size = 18)),
       yaxis = list(title = "Beer consumption",
                    titlefont = list(family = "Courier New, monospace", size =30)))
```

A cleaner way to do the same

```{r message=FALSE, warning=FALSE}
#first font
f1 = list(family = "Comic Sans MS",size = 18)
#second font
f2 = list(family = "Courier New, monospace", size =30)
#xaxis
x = list(title = "where in the world", titlefont = f1)
#yaxis
y = list(title = "Beer consumption", titlefont = f2)

#make the plot
plot_ly(data.vis,
        x=~log10(SQKM_CNTRY),
        y=~beer, 
        type = 'scatter',
        color =~ISLAND,
        colors = "Set1") %>% 
layout(legend = list(x = 0.1, y = 0.9),
       xaxis = x,
       yaxis = y)
```

We can plot side by side for each factor in the descrete variable. Make sure that the data you want to plot is in a long format.

```{r message=FALSE, warning=FALSE}
p <- data.vis %>%
  #transform the variable that will be used to plot to integer type
  transform(id = as.integer(factor(ISLAND))) %>%
  #plot the data where X is the predictor, y is the response, color is thedivider, yaxis is the variable to use to divide the plot
  plot_ly(x = ~beer, y = ~total, color = ~ISLAND, colors = "Dark2",type = "scatter",
          yaxis = ~paste0("y", id)) %>%
  # define the number of subplots and share the x to plot them together
  subplot(nrows = 2, shareX = TRUE)
p
```

We can put lines instead of dots by removing the "scatter" as type and adding the line `add_lines()`

```{r message=FALSE, warning=FALSE}
p <- data.vis %>%
  #transform the variable that will be used to plot to integer type
  transform(id = as.integer(factor(ISLAND))) %>%
  #plot the data where X is the predictor, y is the response, color is thedivider, yaxis is the variable to use to divide the plot
  plot_ly(x = ~beer, y = ~total, color = ~ISLAND, colors = "Dark2",
          yaxis = ~paste0("y", id)) %>%
  #make a line graph instead of just scatterplot
  add_lines() %>%
  # define the number of subplots and share the x to plot them together
  subplot(nrows = 2, shareX = TRUE)
p

```

#### Change the size of the dots based on a variable
```{r message=FALSE, warning=FALSE}
#change size for all dots
p<- plot_ly(data.vis,
        x=~log10(SQKM_CNTRY),
        y=~wine, 
        type = 'scatter',
        color =~LANDLOCKED,
        colors = "Set1",
        mode = "markers",
        marker = list(size = 20)) %>% 
  layout(showlegend = FALSE)
p

#change size based on a continious factor
p<- plot_ly(data.vis,
        x=~log10(SQKM_CNTRY),
        y=~log10(POP_CNTRY), 
        type = 'scatter',
        mode = "markers",
        size = ~total,
        color =~LANDLOCKED,
        colors = "Set1") %>% 
  layout(showlegend = FALSE)
p
```

#### Do line plots
```{r}
plot_ly(data.vis, x = ~log10(POP_CNTRY), y = ~log10(SQKM_CNTRY)) %>%
  add_lines(color = ~LANDLOCKED, colors = "Set1", alpha = 0.9)
```

#### Barplot 
```{r}
p2 <- data.vis %>%
  dplyr::count(Continent) %>%
  plot_ly(x = ~Continent, y = ~n) %>% 
  add_bars()

```
#### Proportion barplot

```{r message=FALSE, warning=FALSE}
# number of wines by continent and whether its and island (n)
cc <- count(data.vis, Continent, ISLAND)
# number of diamonds by Continent (nn)
cc2 <- left_join(cc, count(cc, Continent, wt = n))
cc2 %>%
  mutate(prop = n / nn) %>%
  plot_ly(x = ~Continent, y = ~prop, color = ~ISLAND) %>%
  add_bars() %>%
  layout(barmode = "stack")
```

#### Boxplot 


```{r message=FALSE, warning=FALSE}
#Standard boxplot
p <- plot_ly(data.vis, y = ~total, color = I("darkgreen"), 
             boxpoints = "suspectedoutliers")%>% 
  add_boxplot(x = ~Continent)
p
#faceted boxplot
p<- plot_ly(data.vis, x = ~wine, y = ~interaction(ISLAND, Continent)) %>%
  add_boxplot(color = ~ISLAND) %>%
  layout(yaxis = list(title = ""), margin = list(l = 100))
p
```

#### Exporting localy as html widget. This can be used in a website or presentation

```{r message=FALSE, warning=FALSE}
htmlwidgets::saveWidget(p, "my_pot.html")
```

#### Export static

To export a high quality static plot you need to install an additional package for your OS names orca. Follow this github to unstall it:
https://github.com/plotly/orca#installation
Then write 
```{r}
# orca(p, file='image.png',width = 10,height = 10)
```


## Introduction to ggvis

## Introduction to 3D


# Geographic plotting

We can plot two types of geographical plots in R - stationary and interactive. The first one is done with ggplot the second is mainly done with leaflet but note that there are some more packages out there. We'll start with ggplot

## ggplot2

For this we need a few packages that we uploaded before: `maps`, `mapdata`, and `ggplot2`
* The `maps` package contains a lot of outlines of continents, countries, states, and counties that have been with R for a long time.
* The `mapdata` package contains a few more, higher-resolution outlines.
* The `maps` package comes with a plotting function, but, we will opt to use `ggplot2` to plot the maps in the `maps` package.
* Recall that `ggplot2` operates on data frames. Therefore we need some way to translate the maps data into a data frame format the `ggplot` can use.

First we'll create a world map tamplate that we will use to map our data on it
```{r}
w2hr <- map_data("world2Hires")
```

## leaflet



